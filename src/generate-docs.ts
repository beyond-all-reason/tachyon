import { createHash } from "node:crypto";

import fs from "fs";
import type { TObject, TSchema } from "typebox";

// https://github.com/json-schema-faker/json-schema-faker/issues/800
// @ts-ignore
global.location = new URL(import.meta.url);
import { JSONSchemaFaker } from "json-schema-faker";
import { compile } from "json-schema-to-typescript";
import prand from "pure-rand";

import {
    capitalize,
    type CommandConfig,
    type CompiledSchema,
    mapRefs,
    setTSchemaOptions,
    type TachyonConfig,
} from "@/generate-json-schemas.js";
import { stringifyJsonSchema } from "@/json-schema-format.js";

JSONSchemaFaker.option("useExamplesValue", true);
JSONSchemaFaker.option("useDefaultValue", true);

const autoGeneratedPrefix = `<!-- THIS FILE IS AUTOMATICALLY GENERATED, PLEASE DO NOT EDIT IT MANUALLY -->\n\n`;

export async function generateDocs(tachyonConfig: TachyonConfig) {
    const tachyonSchema: Record<string, Record<string, CommandConfig>> = {};

    for (const serviceId in tachyonConfig.schemaMeta.serviceIds) {
        for (const endpointId of tachyonConfig.schemaMeta.serviceIds[serviceId]) {
            if (!tachyonSchema[serviceId]) {
                tachyonSchema[serviceId] = {};
            }
            tachyonSchema[serviceId][endpointId] =
                tachyonConfig.commandConfigs[`${serviceId}/${endpointId}`];
        }
    }

    let schemaContents = "";
    for (const serviceId in tachyonSchema) {
        schemaContents += `  - [${serviceId}](docs/schema/${serviceId}.md)\n`;
    }

    let mainReadme = await fs.promises.readFile("README.md", { encoding: "utf-8" });
    const regex =
        /(?<=COMMAND_SCHEMA_PLACEHOLDER_START.*$\n)[\s|\S]*(?=^.*COMMAND_SCHEMA_PLACEHOLDER_END.*)/ms;
    if (!mainReadme.match(regex)) {
        throw new Error("Could not find COMMAND_SCHEMA_PLACEHOLDER comment in main README.md");
    }
    mainReadme = mainReadme.replace(regex, schemaContents);
    await fs.promises.writeFile("README.md", mainReadme);

    await fs.promises.mkdir("docs/schema", { recursive: true });
    for (const serviceId in tachyonSchema) {
        const serviceSchema = tachyonSchema[serviceId] as Record<string, CommandConfig>;

        const orderedCommandIds = Object.keys(serviceSchema).sort((a, b) => {
            const orderA = serviceSchema[a]?.config.order ?? Infinity;
            const orderB = serviceSchema[b]?.config.order ?? Infinity;
            return orderA - orderB;
        });

        const orderedCommandConfigs = {} as Record<string, CommandConfig>;
        for (const id of orderedCommandIds) {
            orderedCommandConfigs[id] = tachyonConfig.commandConfigs[`${serviceId}/${id}`];
        }

        const markdown = await generateServiceMarkdown(
            serviceId,
            orderedCommandConfigs,
            tachyonConfig.compiledSchema
        );

        await fs.promises.writeFile(`docs/schema/${serviceId.toString()}.md`, markdown);
    }
}

export async function generateServiceMarkdown(
    serviceId: string,
    endpointConfigs: Record<string, CommandConfig>,
    compiledSchema: CompiledSchema
): Promise<string> {
    let markdown = autoGeneratedPrefix;

    markdown += `# ${capitalize(serviceId)}\n\n`;

    if (fs.existsSync(`src/schema/${serviceId}/README.md`)) {
        const serviceReadme = await fs.promises.readFile(`src/schema/${serviceId}/README.md`, {
            encoding: "utf8",
        });

        markdown += `${serviceReadme}\n---\n`;
    }

    for (const endpointId in endpointConfigs) {
        markdown += `- [${endpointId}](#${endpointId.toLowerCase()})\n`;
    }

    for (const endpointId in endpointConfigs) {
        markdown += await generateEndpointMarkdown(
            serviceId,
            endpointId,
            endpointConfigs[endpointId],
            compiledSchema
        );
    }

    return markdown;
}

function getSchemaCommands(commandConfig: CommandConfig) {
    switch (commandConfig.type) {
        case "requestResponse":
            return [
                { type: "request" as const, schema: commandConfig.schema.request },
                { type: "response" as const, schema: commandConfig.schema.response },
            ];
        case "event":
            return [{ type: "event" as const, schema: commandConfig.schema.event }];
        default: {
            const exhaustiveCheck: never = commandConfig;
            throw new Error(`Unhandled commandConfig.type case: ${exhaustiveCheck}`);
        }
    }
}

type Command = ReturnType<typeof getSchemaCommands>[number];

export async function generateEndpointMarkdown(
    serviceId: string,
    endpointId: string,
    commandConfig: CommandConfig,
    compiledSchema: CompiledSchema
): Promise<string> {
    let markdown = `---\n\n## ${capitalize(endpointId)}\n\n`;

    if (commandConfig.config.description) {
        markdown += `${commandConfig.config.description}\n\n`;
    }

    markdown += `- Endpoint Type: `;

    if (commandConfig.type === "requestResponse") {
        markdown += `**Request** -> **Response**\n`;
    } else {
        markdown += `**Event**\n`;
    }

    markdown += `- Source: **${capitalize(commandConfig.config.source)}**\n`;
    markdown += `- Target: **${capitalize(commandConfig.config.target)}**\n`;

    if (commandConfig.config.scopes.length) {
        markdown += `- Required Scopes: \`${commandConfig.config.scopes}\`\n\n`;
    }

    for (const command of getSchemaCommands(commandConfig)) {
        markdown += await generateCommandMarkdown(
            serviceId,
            endpointId,
            command,
            compiledSchema.definitions
        );
    }

    return markdown;
}

export async function generateCommandMarkdown(
    serviceId: string,
    endpointId: string,
    command: Command,
    definitions: TSchema
): Promise<string> {
    let markdown = `### ${capitalize(command.type)}\n\n`;

    command = { ...command };
    command.schema = setTSchemaOptions(command.schema, { $id: undefined, $schema: undefined });
    command.schema = mapRefs(command.schema, (ref) =>
        ref.replace(/.*\/definitions\/(.*)\.json/, "#/definitions/$1")
    );

    markdown += `<details>
<summary>JSONSchema</summary>\n
\`\`\`json
${await stringifyJsonSchema(command.schema)}
\`\`\`\n</details>\n\n`;

    // TODO: make this cleaner once we update typescript with better inference
    const failedReasons: string[] = [];
    let coreSchema: TObject;
    if (command.type === "response") {
        failedReasons.push(
            ...command.schema.anyOf
                .map((e) => e.properties)
                .filter((p) => "reason" in p)
                .flatMap((p) => p.reason.enum)
        );
        coreSchema = command.schema.anyOf.find((res) => res.properties.status.const === "success")!;
    } else {
        coreSchema = command.schema;
    }

    coreSchema = setTSchemaOptions(coreSchema, { definitions });

    // This ensures the stability in generated outputs for given message independent from
    // other messages.
    const randomSeed = createHash("sha256")
        .update(`${serviceId}/${endpointId}/${command.type}`)
        .digest()
        .readInt32LE(0);
    const rng = prand.xorshift128plus(randomSeed);
    JSONSchemaFaker.option(
        "random",
        () => prand.unsafeUniformIntDistribution(0, (1 << 24) - 1, rng) / (1 << 24)
    );

    const dummyData = await JSONSchemaFaker.resolve(structuredClone(coreSchema));
    markdown += `<details>
<summary>Example</summary>\n
\`\`\`json
${JSON.stringify(dummyData, null, 4)}
\`\`\`\n</details>\n\n`;

    try {
        let typings = await compile(
            coreSchema,
            `${capitalize(serviceId)}${capitalize(endpointId)}${capitalize(command.type)}`,
            {
                additionalProperties: false,
                bannerComment: ``,
                style: {
                    bracketSpacing: true,
                    tabWidth: 4,
                    semi: true,
                },
            }
        );
        typings = typings.replace(/\s*\/\*[\s\S]*?\*\/|(?<=[^:])\/\/.*|^\/\/.*/g, ""); // remove comments

        markdown += `#### TypeScript Definition
\`\`\`ts
${typings.trim()}
\`\`\`
`;

        if (failedReasons.length) {
            markdown += `Possible Failed Reasons: ${failedReasons.map((r) => `\`${r}\``).join(", ")}\n\n`;
        }
    } catch (err) {
        console.log(coreSchema);
        throw err;
    }

    return markdown;
}
